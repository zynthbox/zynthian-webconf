"use strict";
/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunkzynthbox_webconf_metaheader"] = self["webpackChunkzynthbox_webconf_metaheader"] || []).push([["vendors-node_modules_music-metadata_lib_flac_FlacParser_js"],{

/***/ "./node_modules/music-metadata/lib/flac/FlacParser.js":
/*!************************************************************!*\
  !*** ./node_modules/music-metadata/lib/flac/FlacParser.js ***!
  \************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   FlacParser: () => (/* binding */ FlacParser)\n/* harmony export */ });\n/* harmony import */ var token_types__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! token-types */ \"./node_modules/token-types/lib/index.js\");\n/* harmony import */ var debug__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! debug */ \"./node_modules/debug/src/browser.js\");\n/* harmony import */ var _common_Util_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../common/Util.js */ \"./node_modules/music-metadata/lib/common/Util.js\");\n/* harmony import */ var _ogg_vorbis_Vorbis_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../ogg/vorbis/Vorbis.js */ \"./node_modules/music-metadata/lib/ogg/vorbis/Vorbis.js\");\n/* harmony import */ var _id3v2_AbstractID3Parser_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../id3v2/AbstractID3Parser.js */ \"./node_modules/music-metadata/lib/id3v2/AbstractID3Parser.js\");\n/* harmony import */ var _common_FourCC_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../common/FourCC.js */ \"./node_modules/music-metadata/lib/common/FourCC.js\");\n/* harmony import */ var _ogg_vorbis_VorbisParser_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../ogg/vorbis/VorbisParser.js */ \"./node_modules/music-metadata/lib/ogg/vorbis/VorbisParser.js\");\n/* harmony import */ var _ogg_vorbis_VorbisDecoder_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../ogg/vorbis/VorbisDecoder.js */ \"./node_modules/music-metadata/lib/ogg/vorbis/VorbisDecoder.js\");\n/* harmony import */ var _ParseError_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../ParseError.js */ \"./node_modules/music-metadata/lib/ParseError.js\");\n\n\n\n\n\n\n\n\n\nconst debug = debug__WEBPACK_IMPORTED_MODULE_1__('music-metadata:parser:FLAC');\nclass FlacContentError extends (0,_ParseError_js__WEBPACK_IMPORTED_MODULE_8__.makeUnexpectedFileContentError)('FLAC') {\n}\n/**\n * FLAC supports up to 128 kinds of metadata blocks; currently the following are defined:\n * ref: https://xiph.org/flac/format.html#metadata_block\n */\nvar BlockType;\n(function (BlockType) {\n    BlockType[BlockType[\"STREAMINFO\"] = 0] = \"STREAMINFO\";\n    BlockType[BlockType[\"PADDING\"] = 1] = \"PADDING\";\n    BlockType[BlockType[\"APPLICATION\"] = 2] = \"APPLICATION\";\n    BlockType[BlockType[\"SEEKTABLE\"] = 3] = \"SEEKTABLE\";\n    BlockType[BlockType[\"VORBIS_COMMENT\"] = 4] = \"VORBIS_COMMENT\";\n    BlockType[BlockType[\"CUESHEET\"] = 5] = \"CUESHEET\";\n    BlockType[BlockType[\"PICTURE\"] = 6] = \"PICTURE\";\n})(BlockType || (BlockType = {}));\nclass FlacParser extends _id3v2_AbstractID3Parser_js__WEBPACK_IMPORTED_MODULE_4__.AbstractID3Parser {\n    constructor() {\n        super(...arguments);\n        this.vorbisParser = new _ogg_vorbis_VorbisParser_js__WEBPACK_IMPORTED_MODULE_6__.VorbisParser(this.metadata, this.options);\n        this.padding = 0;\n    }\n    async postId3v2Parse() {\n        const fourCC = await this.tokenizer.readToken(_common_FourCC_js__WEBPACK_IMPORTED_MODULE_5__.FourCcToken);\n        if (fourCC.toString() !== 'fLaC') {\n            throw new FlacContentError('Invalid FLAC preamble');\n        }\n        let blockHeader;\n        do {\n            // Read block header\n            blockHeader = await this.tokenizer.readToken(BlockHeader);\n            // Parse block data\n            await this.parseDataBlock(blockHeader);\n        } while (!blockHeader.lastBlock);\n        if (this.tokenizer.fileInfo.size && this.metadata.format.duration) {\n            const dataSize = this.tokenizer.fileInfo.size - this.tokenizer.position;\n            this.metadata.setFormat('bitrate', 8 * dataSize / this.metadata.format.duration);\n        }\n    }\n    async parseDataBlock(blockHeader) {\n        debug(`blockHeader type=${blockHeader.type}, length=${blockHeader.length}`);\n        switch (blockHeader.type) {\n            case BlockType.STREAMINFO:\n                return this.parseBlockStreamInfo(blockHeader.length);\n            case BlockType.PADDING:\n                this.padding += blockHeader.length;\n                break;\n            case BlockType.APPLICATION:\n                break;\n            case BlockType.SEEKTABLE:\n                break;\n            case BlockType.VORBIS_COMMENT:\n                return this.parseComment(blockHeader.length);\n            case BlockType.CUESHEET:\n                break;\n            case BlockType.PICTURE:\n                await this.parsePicture(blockHeader.length);\n                return;\n            default:\n                this.metadata.addWarning(`Unknown block type: ${blockHeader.type}`);\n        }\n        // Ignore data block\n        return this.tokenizer.ignore(blockHeader.length).then();\n    }\n    /**\n     * Parse STREAMINFO\n     */\n    async parseBlockStreamInfo(dataLen) {\n        if (dataLen !== BlockStreamInfo.len)\n            throw new FlacContentError('Unexpected block-stream-info length');\n        const streamInfo = await this.tokenizer.readToken(BlockStreamInfo);\n        this.metadata.setFormat('container', 'FLAC');\n        this.metadata.setFormat('codec', 'FLAC');\n        this.metadata.setFormat('lossless', true);\n        this.metadata.setFormat('numberOfChannels', streamInfo.channels);\n        this.metadata.setFormat('bitsPerSample', streamInfo.bitsPerSample);\n        this.metadata.setFormat('sampleRate', streamInfo.sampleRate);\n        if (streamInfo.totalSamples > 0) {\n            this.metadata.setFormat('duration', streamInfo.totalSamples / streamInfo.sampleRate);\n        }\n    }\n    /**\n     * Parse VORBIS_COMMENT\n     * Ref: https://www.xiph.org/vorbis/doc/Vorbis_I_spec.html#x1-640004.2.3\n     */\n    async parseComment(dataLen) {\n        const data = await this.tokenizer.readToken(new token_types__WEBPACK_IMPORTED_MODULE_0__.Uint8ArrayType(dataLen));\n        const decoder = new _ogg_vorbis_VorbisDecoder_js__WEBPACK_IMPORTED_MODULE_7__.VorbisDecoder(data, 0);\n        decoder.readStringUtf8(); // vendor (skip)\n        const commentListLength = decoder.readInt32();\n        const tags = new Array(commentListLength);\n        for (let i = 0; i < commentListLength; i++) {\n            tags[i] = decoder.parseUserComment();\n        }\n        await Promise.all(tags.map(tag => this.vorbisParser.addTag(tag.key, tag.value)));\n    }\n    async parsePicture(dataLen) {\n        if (this.options.skipCovers) {\n            return this.tokenizer.ignore(dataLen);\n        }\n        const picture = await this.tokenizer.readToken(new _ogg_vorbis_Vorbis_js__WEBPACK_IMPORTED_MODULE_3__.VorbisPictureToken(dataLen));\n        this.vorbisParser.addTag('METADATA_BLOCK_PICTURE', picture);\n    }\n}\nconst BlockHeader = {\n    len: 4,\n    get: (buf, off) => {\n        return {\n            lastBlock: _common_Util_js__WEBPACK_IMPORTED_MODULE_2__.getBit(buf, off, 7),\n            type: _common_Util_js__WEBPACK_IMPORTED_MODULE_2__.getBitAllignedNumber(buf, off, 1, 7),\n            length: token_types__WEBPACK_IMPORTED_MODULE_0__.UINT24_BE.get(buf, off + 1)\n        };\n    }\n};\n/**\n * METADATA_BLOCK_DATA\n * Ref: https://xiph.org/flac/format.html#metadata_block_streaminfo\n */\nconst BlockStreamInfo = {\n    len: 34,\n    get: (buf, off) => {\n        return {\n            // The minimum block size (in samples) used in the stream.\n            minimumBlockSize: token_types__WEBPACK_IMPORTED_MODULE_0__.UINT16_BE.get(buf, off),\n            // The maximum block size (in samples) used in the stream.\n            // (Minimum blocksize == maximum blocksize) implies a fixed-blocksize stream.\n            maximumBlockSize: token_types__WEBPACK_IMPORTED_MODULE_0__.UINT16_BE.get(buf, off + 2) / 1000,\n            // The minimum frame size (in bytes) used in the stream.\n            // May be 0 to imply the value is not known.\n            minimumFrameSize: token_types__WEBPACK_IMPORTED_MODULE_0__.UINT24_BE.get(buf, off + 4),\n            // The maximum frame size (in bytes) used in the stream.\n            // May be 0 to imply the value is not known.\n            maximumFrameSize: token_types__WEBPACK_IMPORTED_MODULE_0__.UINT24_BE.get(buf, off + 7),\n            // Sample rate in Hz. Though 20 bits are available,\n            // the maximum sample rate is limited by the structure of frame headers to 655350Hz.\n            // Also, a value of 0 is invalid.\n            sampleRate: token_types__WEBPACK_IMPORTED_MODULE_0__.UINT24_BE.get(buf, off + 10) >> 4,\n            // probably slower: sampleRate: common.getBitAllignedNumber(buf, off + 10, 0, 20),\n            // (number of channels)-1. FLAC supports from 1 to 8 channels\n            channels: _common_Util_js__WEBPACK_IMPORTED_MODULE_2__.getBitAllignedNumber(buf, off + 12, 4, 3) + 1,\n            // bits per sample)-1.\n            // FLAC supports from 4 to 32 bits per sample. Currently the reference encoder and decoders only support up to 24 bits per sample.\n            bitsPerSample: _common_Util_js__WEBPACK_IMPORTED_MODULE_2__.getBitAllignedNumber(buf, off + 12, 7, 5) + 1,\n            // Total samples in stream.\n            // 'Samples' means inter-channel sample, i.e. one second of 44.1Khz audio will have 44100 samples regardless of the number of channels.\n            // A value of zero here means the number of total samples is unknown.\n            totalSamples: _common_Util_js__WEBPACK_IMPORTED_MODULE_2__.getBitAllignedNumber(buf, off + 13, 4, 36),\n            // the MD5 hash of the file (see notes for usage... it's a littly tricky)\n            fileMD5: new token_types__WEBPACK_IMPORTED_MODULE_0__.Uint8ArrayType(16).get(buf, off + 18)\n        };\n    }\n};\n//# sourceMappingURL=FlacParser.js.map\n\n//# sourceURL=webpack://zynthbox-webconf-metaheader/./node_modules/music-metadata/lib/flac/FlacParser.js?");

/***/ }),

/***/ "./node_modules/music-metadata/lib/id3v2/AbstractID3Parser.js":
/*!********************************************************************!*\
  !*** ./node_modules/music-metadata/lib/id3v2/AbstractID3Parser.js ***!
  \********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AbstractID3Parser: () => (/* binding */ AbstractID3Parser)\n/* harmony export */ });\n/* harmony import */ var strtok3__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! strtok3 */ \"./node_modules/strtok3/lib/core.js\");\n/* harmony import */ var debug__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! debug */ \"./node_modules/debug/src/browser.js\");\n/* harmony import */ var _ID3v2Token_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./ID3v2Token.js */ \"./node_modules/music-metadata/lib/id3v2/ID3v2Token.js\");\n/* harmony import */ var _ID3v2Parser_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./ID3v2Parser.js */ \"./node_modules/music-metadata/lib/id3v2/ID3v2Parser.js\");\n/* harmony import */ var _id3v1_ID3v1Parser_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../id3v1/ID3v1Parser.js */ \"./node_modules/music-metadata/lib/id3v1/ID3v1Parser.js\");\n/* harmony import */ var _common_BasicParser_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../common/BasicParser.js */ \"./node_modules/music-metadata/lib/common/BasicParser.js\");\n\n\n\n\n\n\nconst debug = debug__WEBPACK_IMPORTED_MODULE_1__('music-metadata:parser:ID3');\n/**\n * Abstract parser which tries take ID3v2 and ID3v1 headers.\n */\nclass AbstractID3Parser extends _common_BasicParser_js__WEBPACK_IMPORTED_MODULE_5__.BasicParser {\n    constructor() {\n        super(...arguments);\n        this.id3parser = new _ID3v2Parser_js__WEBPACK_IMPORTED_MODULE_3__.ID3v2Parser();\n    }\n    static async startsWithID3v2Header(tokenizer) {\n        return (await tokenizer.peekToken(_ID3v2Token_js__WEBPACK_IMPORTED_MODULE_2__.ID3v2Header)).fileIdentifier === 'ID3';\n    }\n    async parse() {\n        try {\n            await this.parseID3v2();\n        }\n        catch (err) {\n            if (err instanceof strtok3__WEBPACK_IMPORTED_MODULE_0__.EndOfStreamError) {\n                debug(\"End-of-stream\");\n            }\n            else {\n                throw err;\n            }\n        }\n    }\n    finalize() {\n        return;\n    }\n    async parseID3v2() {\n        await this.tryReadId3v2Headers();\n        debug('End of ID3v2 header, go to MPEG-parser: pos=%s', this.tokenizer.position);\n        await this.postId3v2Parse();\n        if (this.options.skipPostHeaders && this.metadata.hasAny()) {\n            this.finalize();\n        }\n        else {\n            const id3v1parser = new _id3v1_ID3v1Parser_js__WEBPACK_IMPORTED_MODULE_4__.ID3v1Parser(this.metadata, this.tokenizer, this.options);\n            await id3v1parser.parse();\n            this.finalize();\n        }\n    }\n    async tryReadId3v2Headers() {\n        const id3Header = await this.tokenizer.peekToken(_ID3v2Token_js__WEBPACK_IMPORTED_MODULE_2__.ID3v2Header);\n        if (id3Header.fileIdentifier === 'ID3') {\n            debug('Found ID3v2 header, pos=%s', this.tokenizer.position);\n            await this.id3parser.parse(this.metadata, this.tokenizer, this.options);\n            return this.tryReadId3v2Headers();\n        }\n    }\n}\n//# sourceMappingURL=AbstractID3Parser.js.map\n\n//# sourceURL=webpack://zynthbox-webconf-metaheader/./node_modules/music-metadata/lib/id3v2/AbstractID3Parser.js?");

/***/ }),

/***/ "./node_modules/music-metadata/lib/ogg/vorbis/Vorbis.js":
/*!**************************************************************!*\
  !*** ./node_modules/music-metadata/lib/ogg/vorbis/Vorbis.js ***!
  \**************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   CommonHeader: () => (/* binding */ CommonHeader),\n/* harmony export */   IdentificationHeader: () => (/* binding */ IdentificationHeader),\n/* harmony export */   VorbisPictureToken: () => (/* binding */ VorbisPictureToken)\n/* harmony export */ });\n/* harmony import */ var token_types__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! token-types */ \"./node_modules/token-types/lib/index.js\");\n/* harmony import */ var _id3v2_ID3v2Token_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../id3v2/ID3v2Token.js */ \"./node_modules/music-metadata/lib/id3v2/ID3v2Token.js\");\n\n\n/**\n * Parse the METADATA_BLOCK_PICTURE\n * Ref: https://wiki.xiph.org/VorbisComment#METADATA_BLOCK_PICTURE\n * Ref: https://xiph.org/flac/format.html#metadata_block_picture\n * // ToDo: move to ID3 / APIC?\n */\nclass VorbisPictureToken {\n    static fromBase64(base64str) {\n        return VorbisPictureToken.fromBuffer(Uint8Array.from(atob(base64str), c => c.charCodeAt(0)));\n    }\n    static fromBuffer(buffer) {\n        const pic = new VorbisPictureToken(buffer.length);\n        return pic.get(buffer, 0);\n    }\n    constructor(len) {\n        this.len = len;\n    }\n    get(buffer, offset) {\n        const type = _id3v2_ID3v2Token_js__WEBPACK_IMPORTED_MODULE_1__.AttachedPictureType[token_types__WEBPACK_IMPORTED_MODULE_0__.UINT32_BE.get(buffer, offset)];\n        offset += 4;\n        const mimeLen = token_types__WEBPACK_IMPORTED_MODULE_0__.UINT32_BE.get(buffer, offset);\n        offset += 4;\n        const format = new token_types__WEBPACK_IMPORTED_MODULE_0__.StringType(mimeLen, 'utf-8').get(buffer, offset);\n        offset += mimeLen;\n        const descLen = token_types__WEBPACK_IMPORTED_MODULE_0__.UINT32_BE.get(buffer, offset);\n        offset += 4;\n        const description = new token_types__WEBPACK_IMPORTED_MODULE_0__.StringType(descLen, 'utf-8').get(buffer, offset);\n        offset += descLen;\n        const width = token_types__WEBPACK_IMPORTED_MODULE_0__.UINT32_BE.get(buffer, offset);\n        offset += 4;\n        const height = token_types__WEBPACK_IMPORTED_MODULE_0__.UINT32_BE.get(buffer, offset);\n        offset += 4;\n        const colour_depth = token_types__WEBPACK_IMPORTED_MODULE_0__.UINT32_BE.get(buffer, offset);\n        offset += 4;\n        const indexed_color = token_types__WEBPACK_IMPORTED_MODULE_0__.UINT32_BE.get(buffer, offset);\n        offset += 4;\n        const picDataLen = token_types__WEBPACK_IMPORTED_MODULE_0__.UINT32_BE.get(buffer, offset);\n        offset += 4;\n        const data = Uint8Array.from(buffer.slice(offset, offset + picDataLen));\n        return {\n            type,\n            format,\n            description,\n            width,\n            height,\n            colour_depth,\n            indexed_color,\n            data\n        };\n    }\n}\n/**\n * Comment header decoder\n * Ref: https://xiph.org/vorbis/doc/Vorbis_I_spec.html#x1-620004.2.1\n */\nconst CommonHeader = {\n    len: 7,\n    get: (buf, off) => {\n        return {\n            packetType: token_types__WEBPACK_IMPORTED_MODULE_0__.UINT8.get(buf, off),\n            vorbis: new token_types__WEBPACK_IMPORTED_MODULE_0__.StringType(6, 'ascii').get(buf, off + 1)\n        };\n    }\n};\n/**\n * Identification header decoder\n * Ref: https://xiph.org/vorbis/doc/Vorbis_I_spec.html#x1-630004.2.2\n */\nconst IdentificationHeader = {\n    len: 23,\n    get: (uint8Array, off) => {\n        return {\n            version: token_types__WEBPACK_IMPORTED_MODULE_0__.UINT32_LE.get(uint8Array, off + 0),\n            channelMode: token_types__WEBPACK_IMPORTED_MODULE_0__.UINT8.get(uint8Array, off + 4),\n            sampleRate: token_types__WEBPACK_IMPORTED_MODULE_0__.UINT32_LE.get(uint8Array, off + 5),\n            bitrateMax: token_types__WEBPACK_IMPORTED_MODULE_0__.UINT32_LE.get(uint8Array, off + 9),\n            bitrateNominal: token_types__WEBPACK_IMPORTED_MODULE_0__.UINT32_LE.get(uint8Array, off + 13),\n            bitrateMin: token_types__WEBPACK_IMPORTED_MODULE_0__.UINT32_LE.get(uint8Array, off + 17)\n        };\n    }\n};\n//# sourceMappingURL=Vorbis.js.map\n\n//# sourceURL=webpack://zynthbox-webconf-metaheader/./node_modules/music-metadata/lib/ogg/vorbis/Vorbis.js?");

/***/ }),

/***/ "./node_modules/music-metadata/lib/ogg/vorbis/VorbisDecoder.js":
/*!*********************************************************************!*\
  !*** ./node_modules/music-metadata/lib/ogg/vorbis/VorbisDecoder.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   VorbisDecoder: () => (/* binding */ VorbisDecoder)\n/* harmony export */ });\n/* harmony import */ var token_types__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! token-types */ \"./node_modules/token-types/lib/index.js\");\n\nclass VorbisDecoder {\n    constructor(data, offset) {\n        this.data = data;\n        this.offset = offset;\n    }\n    readInt32() {\n        const value = token_types__WEBPACK_IMPORTED_MODULE_0__.UINT32_LE.get(this.data, this.offset);\n        this.offset += 4;\n        return value;\n    }\n    readStringUtf8() {\n        const len = this.readInt32();\n        const value = new TextDecoder('utf-8').decode(this.data.subarray(this.offset, this.offset + len));\n        this.offset += len;\n        return value;\n    }\n    parseUserComment() {\n        const offset0 = this.offset;\n        const v = this.readStringUtf8();\n        const idx = v.indexOf('=');\n        return {\n            key: v.slice(0, idx).toUpperCase(),\n            value: v.slice(idx + 1),\n            len: this.offset - offset0\n        };\n    }\n}\n//# sourceMappingURL=VorbisDecoder.js.map\n\n//# sourceURL=webpack://zynthbox-webconf-metaheader/./node_modules/music-metadata/lib/ogg/vorbis/VorbisDecoder.js?");

/***/ }),

/***/ "./node_modules/music-metadata/lib/ogg/vorbis/VorbisParser.js":
/*!********************************************************************!*\
  !*** ./node_modules/music-metadata/lib/ogg/vorbis/VorbisParser.js ***!
  \********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   VorbisContentError: () => (/* binding */ VorbisContentError),\n/* harmony export */   VorbisParser: () => (/* binding */ VorbisParser)\n/* harmony export */ });\n/* harmony import */ var token_types__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! token-types */ \"./node_modules/token-types/lib/index.js\");\n/* harmony import */ var debug__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! debug */ \"./node_modules/debug/src/browser.js\");\n/* harmony import */ var _VorbisDecoder_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./VorbisDecoder.js */ \"./node_modules/music-metadata/lib/ogg/vorbis/VorbisDecoder.js\");\n/* harmony import */ var _Vorbis_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./Vorbis.js */ \"./node_modules/music-metadata/lib/ogg/vorbis/Vorbis.js\");\n/* harmony import */ var _ParseError_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../ParseError.js */ \"./node_modules/music-metadata/lib/ParseError.js\");\n\n\n\n\n\nconst debug = debug__WEBPACK_IMPORTED_MODULE_1__('music-metadata:parser:ogg:vorbis1');\nclass VorbisContentError extends (0,_ParseError_js__WEBPACK_IMPORTED_MODULE_4__.makeUnexpectedFileContentError)('Vorbis') {\n}\n/**\n * Vorbis 1 Parser.\n * Used by OggParser\n */\nclass VorbisParser {\n    constructor(metadata, options) {\n        this.metadata = metadata;\n        this.options = options;\n        this.pageSegments = [];\n    }\n    /**\n     * Vorbis 1 parser\n     * @param header Ogg Page Header\n     * @param pageData Page data\n     */\n    async parsePage(header, pageData) {\n        if (header.headerType.firstPage) {\n            this.parseFirstPage(header, pageData);\n        }\n        else {\n            if (header.headerType.continued) {\n                if (this.pageSegments.length === 0) {\n                    throw new VorbisContentError('Cannot continue on previous page');\n                }\n                this.pageSegments.push(pageData);\n            }\n            if (header.headerType.lastPage || !header.headerType.continued) {\n                // Flush page segments\n                if (this.pageSegments.length > 0) {\n                    const fullPage = VorbisParser.mergeUint8Arrays(this.pageSegments);\n                    await this.parseFullPage(fullPage);\n                }\n                // Reset page segments\n                this.pageSegments = header.headerType.lastPage ? [] : [pageData];\n            }\n        }\n        if (header.headerType.lastPage) {\n            this.calculateDuration(header);\n        }\n    }\n    static mergeUint8Arrays(arrays) {\n        const totalSize = arrays.reduce((acc, e) => acc + e.length, 0);\n        const merged = new Uint8Array(totalSize);\n        arrays.forEach((array, i, _arrays) => {\n            const offset = _arrays.slice(0, i).reduce((acc, e) => acc + e.length, 0);\n            merged.set(array, offset);\n        });\n        return merged;\n    }\n    async flush() {\n        await this.parseFullPage(VorbisParser.mergeUint8Arrays(this.pageSegments));\n    }\n    async parseUserComment(pageData, offset) {\n        const decoder = new _VorbisDecoder_js__WEBPACK_IMPORTED_MODULE_2__.VorbisDecoder(pageData, offset);\n        const tag = decoder.parseUserComment();\n        await this.addTag(tag.key, tag.value);\n        return tag.len;\n    }\n    async addTag(id, value) {\n        if (id === 'METADATA_BLOCK_PICTURE' && (typeof value === 'string')) {\n            if (this.options.skipCovers) {\n                debug(\"Ignore picture\");\n                return;\n            }\n            value = _Vorbis_js__WEBPACK_IMPORTED_MODULE_3__.VorbisPictureToken.fromBase64(value);\n            debug(`Push picture: id=${id}, format=${value.format}`);\n        }\n        else {\n            debug(`Push tag: id=${id}, value=${value}`);\n        }\n        await this.metadata.addTag('vorbis', id, value);\n    }\n    calculateDuration(header) {\n        if (this.metadata.format.sampleRate && header.absoluteGranulePosition >= 0) {\n            // Calculate duration\n            this.metadata.setFormat('numberOfSamples', header.absoluteGranulePosition);\n            this.metadata.setFormat('duration', header.absoluteGranulePosition / this.metadata.format.sampleRate);\n        }\n    }\n    /**\n     * Parse first Ogg/Vorbis page\n     * @param header\n     * @param pageData\n     */\n    parseFirstPage(header, pageData) {\n        this.metadata.setFormat('codec', 'Vorbis I');\n        debug('Parse first page');\n        // Parse  Vorbis common header\n        const commonHeader = _Vorbis_js__WEBPACK_IMPORTED_MODULE_3__.CommonHeader.get(pageData, 0);\n        if (commonHeader.vorbis !== 'vorbis')\n            throw new VorbisContentError('Metadata does not look like Vorbis');\n        if (commonHeader.packetType === 1) {\n            const idHeader = _Vorbis_js__WEBPACK_IMPORTED_MODULE_3__.IdentificationHeader.get(pageData, _Vorbis_js__WEBPACK_IMPORTED_MODULE_3__.CommonHeader.len);\n            this.metadata.setFormat('sampleRate', idHeader.sampleRate);\n            this.metadata.setFormat('bitrate', idHeader.bitrateNominal);\n            this.metadata.setFormat('numberOfChannels', idHeader.channelMode);\n            debug('sample-rate=%s[hz], bitrate=%s[b/s], channel-mode=%s', idHeader.sampleRate, idHeader.bitrateNominal, idHeader.channelMode);\n        }\n        else\n            throw new VorbisContentError('First Ogg page should be type 1: the identification header');\n    }\n    async parseFullPage(pageData) {\n        // New page\n        const commonHeader = _Vorbis_js__WEBPACK_IMPORTED_MODULE_3__.CommonHeader.get(pageData, 0);\n        debug('Parse full page: type=%s, byteLength=%s', commonHeader.packetType, pageData.byteLength);\n        switch (commonHeader.packetType) {\n            case 3: //  type 3: comment header\n                return this.parseUserCommentList(pageData, _Vorbis_js__WEBPACK_IMPORTED_MODULE_3__.CommonHeader.len);\n            case 1: // type 1: the identification header\n            case 5: // type 5: setup header type\n                break; // ignore\n        }\n    }\n    /**\n     * Ref: https://xiph.org/vorbis/doc/Vorbis_I_spec.html#x1-840005.2\n     */\n    async parseUserCommentList(pageData, offset) {\n        const strLen = token_types__WEBPACK_IMPORTED_MODULE_0__.UINT32_LE.get(pageData, offset);\n        offset += 4;\n        // const vendorString = new Token.StringType(strLen, 'utf-8').get(pageData, offset);\n        offset += strLen;\n        let userCommentListLength = token_types__WEBPACK_IMPORTED_MODULE_0__.UINT32_LE.get(pageData, offset);\n        offset += 4;\n        while (userCommentListLength-- > 0) {\n            offset += (await this.parseUserComment(pageData, offset));\n        }\n    }\n}\n//# sourceMappingURL=VorbisParser.js.map\n\n//# sourceURL=webpack://zynthbox-webconf-metaheader/./node_modules/music-metadata/lib/ogg/vorbis/VorbisParser.js?");

/***/ })

}]);